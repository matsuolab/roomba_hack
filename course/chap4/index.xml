<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Chapter 4 | ロボットシステム入門</title><link>https://matsuolab.github.io/roomba_hack/course/chap4/</link><atom:link href="https://matsuolab.github.io/roomba_hack/course/chap4/index.xml" rel="self" type="application/rss+xml"/><description>Chapter 4</description><generator>Wowchemy (https://wowchemy.com)</generator><language>ja</language><copyright>© 2022 Tokyo Robot And Intelligence Lab (TRAIL)</copyright><lastBuildDate>Sun, 09 Sep 2018 00:00:00 +0000</lastBuildDate><image><url>https://matsuolab.github.io/roomba_hack/media/icon_hua2ec155b4296a9c9791d015323e16eb5_11927_512x512_fill_lanczos_center_2.png</url><title>Chapter 4</title><link>https://matsuolab.github.io/roomba_hack/course/chap4/</link></image><item><title>自己位置推定</title><link>https://matsuolab.github.io/roomba_hack/course/chap4/localization/</link><pubDate>Sat, 22 Jan 2022 00:00:00 +0000</pubDate><guid>https://matsuolab.github.io/roomba_hack/course/chap4/localization/</guid><description>&lt;h2 id="learn">Learn&lt;/h2>
&lt;p>前回の演習では、オドメトリを用いてロボットを制御しました。&lt;/p>
&lt;p>1m進むや、90度右回転などある程度正確に動いたかと思います。
しかし、これが数10m前進や、数分間動き続けた時にロボット自身は自分がスタートの時からどのくらい動いたかわかるでしょうか。&lt;/p>
&lt;p>ルンバが用いているホイールオドメトリは、ホイールの回転量を積算することで算出しています。ホイールが滑った場合だけでなく、センサの僅かの誤差の積み重ねで徐々にずれていってしまいます。&lt;/p>
&lt;p>そこで今回は、オドメトリ情報だけでなく、地図とLiDARスキャン情報も同時に使いながら、ロボット自身の尤もらしい位置を推定していきましょう。&lt;/p>
&lt;h3 id="rosにおける座標系の扱い方tf">ROSにおける座標系の扱い方(TF)&lt;/h3>
&lt;p>まずは、ROSにおける座標系の扱い方についてみていきましょう。
ロボットシステムは、いろいろな座標系を使って位置姿勢を表現することが多いです。&lt;/p>
&lt;ul>
&lt;li>ロボットの座標系&lt;/li>
&lt;li>センサの座標系&lt;/li>
&lt;li>ロボットの関節の座標系&lt;/li>
&lt;li>部屋の座標系&lt;/li>
&lt;li>物体の座標系&lt;/li>
&lt;li>・・・・&lt;/li>
&lt;/ul>
&lt;p>このような座標系同士を繋げてロボットシステム上での座標系の管理をしてくれるROSのモジュールとしてtfがあります。
tfは、各座標系をツリー上で繋げます。従って、親の座標系が複数あることは許されません。&lt;/p>
&lt;p>今回自己位置推定するにあたり用いる座標系の関係は以下のようになります。&lt;/p>
&lt;p>&lt;code>rosrun rqt_tf_tree rqt_tf_tree&lt;/code>としてみると、tfのツリー形状を可視化することができます。&lt;/p>
&lt;figure id="figure-tfツリーをrqtで可視化">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../rqt_tf_tree.png" alt="tfツリーをrqtで可視化" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
tfツリーをrqtで可視化
&lt;/figcaption>&lt;/figure>
&lt;p>ここで、odom座標系は、オドメトリの算出を始めた位置(起動した位置)を原点とした座標系で、ホイールオドメトリの値から、ロボットの基準となるbase_footprint座標系を繋げています。
base_footprint座標系の下には、ルンバロボットの構成要素である、センサ類やホイールなどの座標系が子として繋がっています。&lt;/p>
&lt;p>一番親にいるmap座標系は、地図の原点を基準とした座標系ですが、この座標系におけるロボットの座標系(base_footprint)を繋げることが、自己位置推定の目的になります。
しかし、base_footprintの親には既にodomがいるため、map座標系とodom座標系を繋げることで、全体をひとつのツリーとして管理することができます。&lt;/p>
&lt;h3 id="自己位置推定">自己位置推定&lt;/h3>
&lt;p>自己位置推定は、地図が事前に与えられていて、そこのどこにロボットがいるかを逐次的に外界センサ(LiDAR)と内界センサ(Odometry)を用いて推定していく手法になります。&lt;/p>
&lt;p>ヒストグラムフィルタやカルマンフィルタ、パーティクルフィルタなどいくつかの手法が存在し、
それぞれメリットデメリットがありますが、ここでは代表的なパーティクルフィルタを用いた手法を紹介します。&lt;/p>
&lt;p>自己位置推定では、観測モデルと状態遷移モデルを交互に繰り返すことによって、ロボット自身がどこにいるかの確率分布を更新していくことで自己位置推定をしていきます。&lt;/p>
&lt;p>パーティクルフィルタでは、この確率分布を大量の粒子を用いて表現する手法になっていて、各粒子が位置とそこにロボットがいるであろう確率(尤度)を持っています。&lt;/p>
&lt;p>ロボットが動くごと(オドメトリが更新されるごと)に、状態遷移モデルを用いて各粒子の位置情報を更新します。
この時、一般的に分布は広がります。(人間が目を閉じて歩いたらどこにいるか分かりづらくなるのと同じ)&lt;/p>
&lt;p>外界の情報がわかるごと(スキャン情報が更新されるごと)に、観測モデルを用いて各粒子の尤度を更新します。
尤度は、各粒子の位置から観測できるであろうスキャン情報と、実際のロボットで取得したスキャン情報との差から算出します。&lt;/p>
&lt;figure id="figure-monte-carlo-localizationparticle-filter-dieter-fox-et-al-1999-using-sonar-httpwwwdocicacukajdroboticsroboticsresourcesmontecarlolocalizationgif">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../montecarlolocalization.gif" alt="Monte Carlo Localization(Particle Filter) Dieter Fox et al. 1999, using sonar. http://www.doc.ic.ac.uk/~ajd/Robotics/RoboticsResources/montecarlolocalization.gif" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
Monte Carlo Localization(Particle Filter) Dieter Fox et al. 1999, using sonar. &lt;a href="http://www.doc.ic.ac.uk/~ajd/Robotics/RoboticsResources/montecarlolocalization.gif">http://www.doc.ic.ac.uk/~ajd/Robotics/RoboticsResources/montecarlolocalization.gif&lt;/a>
&lt;/figcaption>&lt;/figure>
&lt;!-- リサンプリング -->
&lt;h3 id="launchファイルとrosparam">launchファイルとrosparam&lt;/h3>
&lt;p>自己位置推定では、初期位置がどこか、レーザーのスペックや、パーティクルの数など数十個のパラメータを保持します。&lt;/p>
&lt;p>これらをプログラム内部で記述するのではなく、launchファイル内で指定することが可能です。
rosでは、rosparamという形でパラメータを管理することが可能です。&lt;/p>
&lt;p>以下に、今回用いる&lt;code>amcl.launch&lt;/code> を示します。
launchファイルはxml形式で記述され、paramを指定すること以外にも、
launchファイル実行時に引数で指定可能なargや、トピック名などのリマップをすることも可能です。&lt;/p>
&lt;p>launchの詳しい書き方は、&lt;a href="http://wiki.ros.org/ja/roslaunch/XML" target="_blank" rel="noopener">rosのドキュメント&lt;/a>を参照してください。&lt;/p>
&lt;pre>&lt;code class="language-xml">&amp;lt;?xml version=&amp;quot;1.0&amp;quot;?&amp;gt;
&amp;lt;launch&amp;gt;
&amp;lt;arg name=&amp;quot;use_map_topic&amp;quot; default=&amp;quot;true&amp;quot;/&amp;gt;
&amp;lt;arg name=&amp;quot;odom_topic&amp;quot; default=&amp;quot;/odom&amp;quot; /&amp;gt;
&amp;lt;arg name=&amp;quot;scan_topic&amp;quot; default=&amp;quot;/scan&amp;quot; /&amp;gt;
&amp;lt;node pkg=&amp;quot;amcl&amp;quot; type=&amp;quot;amcl&amp;quot; name=&amp;quot;amcl&amp;quot; output=&amp;quot;screen&amp;quot;&amp;gt;
&amp;lt;remap from=&amp;quot;scan&amp;quot; to=&amp;quot;$(arg scan_topic)&amp;quot;/&amp;gt;
&amp;lt;remap from=&amp;quot;odom&amp;quot; to=&amp;quot;$(arg odom_topic)&amp;quot;/&amp;gt;
&amp;lt;param name=&amp;quot;use_map_topic&amp;quot; value=&amp;quot;$(arg use_map_topic)&amp;quot;/&amp;gt;
&amp;lt;param name=&amp;quot;initial_pose_x&amp;quot; value=&amp;quot;0.0&amp;quot;/&amp;gt;
&amp;lt;param name=&amp;quot;initial_pose_y&amp;quot; value=&amp;quot;0.0&amp;quot;/&amp;gt;
&amp;lt;param name=&amp;quot;initial_pose_a&amp;quot; value=&amp;quot;0.0&amp;quot;/&amp;gt;
&amp;lt;param name=&amp;quot;initial_cov_xx&amp;quot; value=&amp;quot;0.1*0.1&amp;quot;/&amp;gt;
&amp;lt;param name=&amp;quot;initial_cov_yy&amp;quot; value=&amp;quot;0.1*0.1&amp;quot;/&amp;gt;
&amp;lt;param name=&amp;quot;initial_cov_aa&amp;quot; value=&amp;quot;0.3*3.14&amp;quot;/&amp;gt;
&amp;lt;param name=&amp;quot;gui_publish_rate&amp;quot; value=&amp;quot;10.0&amp;quot;/&amp;gt;
&amp;lt;param name=&amp;quot;laser_max_beams&amp;quot; value=&amp;quot;2.0&amp;quot;/&amp;gt;
&amp;lt;param name=&amp;quot;laser_min_range&amp;quot; value=&amp;quot;0.15&amp;quot;/&amp;gt;
&amp;lt;param name=&amp;quot;laser_max_range&amp;quot; value=&amp;quot;12.0&amp;quot;/&amp;gt;
&amp;lt;param name=&amp;quot;laser_z_hit&amp;quot; value=&amp;quot;0.8&amp;quot;/&amp;gt;
&amp;lt;param name=&amp;quot;laser_z_short&amp;quot; value=&amp;quot;0.1&amp;quot;/&amp;gt;
&amp;lt;param name=&amp;quot;laser_z_max&amp;quot; value=&amp;quot;0.1&amp;quot;/&amp;gt;
&amp;lt;param name=&amp;quot;laser_z_rand&amp;quot; value=&amp;quot;0.1&amp;quot;/&amp;gt;
&amp;lt;param name=&amp;quot;laser_sigma_hit&amp;quot; value=&amp;quot;0.2&amp;quot;/&amp;gt;
&amp;lt;param name=&amp;quot;laser_lambda_short&amp;quot; value=&amp;quot;0.1&amp;quot;/&amp;gt;
&amp;lt;param name=&amp;quot;laser_model_type&amp;quot; value=&amp;quot;likelihood_field&amp;quot;/&amp;gt;
&amp;lt;param name=&amp;quot;laser_likelihood_max_dist&amp;quot; value=&amp;quot;2.0&amp;quot;/&amp;gt;
&amp;lt;param name=&amp;quot;min_particles&amp;quot; value=&amp;quot;100&amp;quot;/&amp;gt;
&amp;lt;param name=&amp;quot;max_particles&amp;quot; value=&amp;quot;1000&amp;quot;/&amp;gt;
&amp;lt;param name=&amp;quot;kld_err&amp;quot; value=&amp;quot;0.0&amp;quot;/&amp;gt;
&amp;lt;param name=&amp;quot;kld_z&amp;quot; value=&amp;quot;0.0&amp;quot;/&amp;gt;
&amp;lt;param name=&amp;quot;update_min_d&amp;quot; value=&amp;quot;0.1&amp;quot;/&amp;gt;
&amp;lt;param name=&amp;quot;update_min_a&amp;quot; value=&amp;quot;0.1&amp;quot;/&amp;gt;
&amp;lt;param name=&amp;quot;resample_interval&amp;quot; value=&amp;quot;1&amp;quot;/&amp;gt;
&amp;lt;param name=&amp;quot;transform_tolerance&amp;quot; value=&amp;quot;0.2&amp;quot;/&amp;gt;
&amp;lt;param name=&amp;quot;recovery_alpha_slow&amp;quot; value=&amp;quot;0.001&amp;quot;/&amp;gt;
&amp;lt;param name=&amp;quot;recovery_alpha_fast&amp;quot; value=&amp;quot;0.1&amp;quot;/&amp;gt;
&amp;lt;param name=&amp;quot;odom_frame_id&amp;quot; value=&amp;quot;odom&amp;quot;/&amp;gt;
&amp;lt;param name=&amp;quot;odom_model_type&amp;quot; value=&amp;quot;diff&amp;quot;/&amp;gt;
&amp;lt;param name=&amp;quot;odom_alpha1&amp;quot; value=&amp;quot;0.2&amp;quot;/&amp;gt;
&amp;lt;param name=&amp;quot;odom_alpha2&amp;quot; value=&amp;quot;0.2&amp;quot;/&amp;gt;
&amp;lt;param name=&amp;quot;odom_alpha3&amp;quot; value=&amp;quot;0.2&amp;quot;/&amp;gt;
&amp;lt;param name=&amp;quot;odom_alpha4&amp;quot; value=&amp;quot;0.2&amp;quot;/&amp;gt;
&amp;lt;param name=&amp;quot;odom_alpha5&amp;quot; value=&amp;quot;0.2&amp;quot;/&amp;gt;
&amp;lt;/node&amp;gt;
&amp;lt;/launch&amp;gt;
&lt;/code>&lt;/pre>
&lt;h2 id="演習">演習&lt;/h2>
&lt;details class="spoiler " id="spoiler-2">
&lt;summary>【jetson・開発マシン】それぞれdockerコンテナを起動&lt;/summary>
&lt;p>&lt;p>jetsonでdockerコンテナを起動&lt;/p>
&lt;pre>&lt;code class="language-shell">(開発PC):~$ ssh roomba_dev1
(jetson):~$ cd ~/group_a/roomba_hack
(jetson):~/group_a/roomba_hack ./RUN-DOCKER-CONTAINER.sh
(jetson)(docker):~/roomba_hack# roslaunch roomba_bringup bringup.launch
&lt;/code>&lt;/pre>
&lt;p>開発PCでdockerコンテナを起動&lt;/p>
&lt;pre>&lt;code class="language-shell">(開発PC)./RUN-DOCKER-CONTAINER.sh 192.168.10.7x
&lt;/code>&lt;/pre>
&lt;/p>
&lt;/details>
&lt;details class="spoiler " id="spoiler-3">
&lt;summary>gmappingで地図作成&lt;/summary>
&lt;p>&lt;pre>&lt;code>(開発PC)(docker) roslaunch navigation_tutorial gmapping.launch
&lt;/code>&lt;/pre>
&lt;p>地図の保存。map.pgm（画像データ）とmap.yaml(地図情報)が保存される。&lt;/p>
&lt;pre>&lt;code>(開発PC)(docker) rosrun map_server map_saver
&lt;/code>&lt;/pre>
&lt;p>&lt;code>~/roomba_hack/catkin_ws/src/navigation_tutorial/map&lt;/code> の下に保存する。&lt;/p>
&lt;/p>
&lt;/details>
&lt;details class="spoiler " id="spoiler-4">
&lt;summary>amclをlaunchして、自己位置推定する&lt;/summary>
&lt;p>&lt;p>localizationノードと地図サーバーを同時に起動。&lt;/p>
&lt;pre>&lt;code>(開発PC)(docker) roslaunch navigation_tutorial localization.launch
(開発PC)(docker) roslaunch roomba_teleop teleop.launch
(開発PC)(docker) rviz -d /root/roomba_hack/catkin_ws/src/navigation_tutorial/configs/navigation.rviz
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>初期位置の指定(rvizの2D Pose Estimate)&lt;/li>
&lt;li>コントローラで移動させてみて自己位置を確認&lt;/li>
&lt;li>rqt_tf_treeを見てみる&lt;/li>
&lt;/ul>
&lt;/p>
&lt;/details>
&lt;details class="spoiler " id="spoiler-5">
&lt;summary>amclのparamをチューニングする&lt;/summary>
&lt;p>&lt;p>launchファイルの中身を見てみて、値を変えてみる。&lt;/p>
&lt;p>各パラメータの意味は&lt;a href="https://wiki.ros.org/amcl#Parameters">amclのページ&lt;/a>を参照。&lt;/p>
&lt;p>例えば、・・・&lt;/p>
&lt;ul>
&lt;li>initial_cov_** を大きくしてみて、パーティクルがちゃんと収束するかみてみる。&lt;/li>
&lt;li>particleの数(min_particles、max_particles)を変えてみて挙動をみてみる。&lt;/li>
&lt;/ul>
&lt;/p>
&lt;/details></description></item><item><title>ナビゲーション</title><link>https://matsuolab.github.io/roomba_hack/course/chap4/navigation/</link><pubDate>Fri, 01 Jan 2021 00:00:00 +0000</pubDate><guid>https://matsuolab.github.io/roomba_hack/course/chap4/navigation/</guid><description>&lt;h2 id="learn">Learn&lt;/h2>
&lt;h3 id="navigationシステム">Navigationシステム&lt;/h3>
&lt;p>ナビゲーションは、地図上の任意の目標地点へ、障害物を避けながらなるべく早く自律して移動することが目的です。&lt;/p>
&lt;p>ナビゲーションシステムの出力はロボットへの行動指令値(速度など)ですが、入力は以下の4つになります。&lt;/p>
&lt;ul>
&lt;li>地図&lt;/li>
&lt;li>目標位置&lt;/li>
&lt;li>自己位置推定結果&lt;/li>
&lt;li>リアルタイムのセンサ情報(LiDARスキャン情報など)&lt;/li>
&lt;/ul>
&lt;p>ナビゲーションでは、地図全体とロボット周辺(センサで見える範囲)の大きく2つに分けて考えることが多いです。&lt;/p>
&lt;p>地図全体を考えるグローバルパスプランでは、地図情報とゴール情報から大まかなゴールまでの経路を算出します。&lt;/p>
&lt;p>ロボット周辺を考える ローカルパスプランでは、グローバルで算出した経路に沿うようにしつつ、周辺の障害物情報を避ける行動指令値を算出します。&lt;/p>
&lt;p>それぞれの経路を考えるにあたって、経路のコストがどうなるか重要になります。
このコストを表現する方法として、コストマップが用いられることが多いです。&lt;/p>
&lt;figure id="figure-navigationシステム概要from-ros-wikihttpswikirosorgmove_base">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../overview_tf_small.png" alt="Navigationシステム概要(from [ROS wiki](https://wiki.ros.org/move_base))" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
Navigationシステム概要(from &lt;a href="https://wiki.ros.org/move_base">ROS wiki&lt;/a>)
&lt;/figcaption>&lt;/figure>
&lt;h3 id="cost-map">Cost Map&lt;/h3>
&lt;p>コストマップは、経路を算出するために用いることから、扱いやすいグリット上の占有格子地図という形で表現されることが多いです。&lt;/p>
&lt;p>(空を飛んだり、3次元地形を考えなくていい場合は、基本2次元で表現します。)&lt;/p>
&lt;p>経路は格子地図上で、点で扱うことが多いですが、ロボット自身はある程度の大きさを持っているので、スキャン情報で得られた点ギリギリに経路を生成すると、衝突してしまします。&lt;/p>
&lt;p>そのため、コストマップでは以下の図のようにスキャンで得られた点(図中の赤点)から、ロボットが入ってほしくない範囲にコスト(図中の青く塗りつぶされているところ)が付与するという表現をします。&lt;/p>
&lt;figure id="figure-コストマップ概要from-ros-wikihttpswikirosorgcostmap_2d">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../costmap_rviz.png" alt="コストマップ概要(from [ROS wiki](https://wiki.ros.org/costmap_2d))" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
コストマップ概要(from &lt;a href="https://wiki.ros.org/costmap_2d">ROS wiki&lt;/a>)
&lt;/figcaption>&lt;/figure>
&lt;h3 id="global-path-planning">Global Path Planning&lt;/h3>
&lt;p>グローバルパスプランの例として、グラフ探索を利用したダイクストラ法やA*法などで経路探索をすることがあります。&lt;/p>
&lt;figure id="figure-グローバルパスプランの例from-pythonroboticshttpsgithubcomatsushisakaipythonrobotics">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../astar.gif" alt="グローバルパスプランの例(from [PythonRobotics](https://github.com/AtsushiSakai/PythonRobotics))" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
グローバルパスプランの例(from &lt;a href="https://github.com/AtsushiSakai/PythonRobotics">PythonRobotics&lt;/a>)
&lt;/figcaption>&lt;/figure>
&lt;h3 id="local-path-planning">Local Path Planning&lt;/h3>
&lt;p>局所経路計画(Local Path Planning)は、ロボット周辺の障害物を避けながら、目標値へ早く行けるような経路(ロボットの行動)を算出するモジュールです。&lt;/p>
&lt;p>代表的なアルゴリズムとしてDynamic Window Approach(DWA)というものがあります。
&lt;figure id="figure-ローカルパスプラン概要from-ros-wikihttpswikirosorgbase_local_planner">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../local_plan.png" alt="ローカルパスプラン概要(from [ROS wiki](https://wiki.ros.org/base_local_planner))" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
ローカルパスプラン概要(from &lt;a href="https://wiki.ros.org/base_local_planner">ROS wiki&lt;/a>)
&lt;/figcaption>&lt;/figure>&lt;/p>
&lt;p>アルゴリズムの概要は以下になります。&lt;/p>
&lt;ol>
&lt;li>ロボットの行動空間から行動をサンプル&lt;/li>
&lt;li>サンプルした行動とロボットの運動モデルを用いて、一定時間シミュレーションをして経路を生成&lt;/li>
&lt;li>生成した経路ごとに、コストマップやゴール情報からコストを算出&lt;/li>
&lt;li>コスト最小の経路を選択し、ロボットの指令値とする&lt;/li>
&lt;li>1~4を繰り返す&lt;/li>
&lt;/ol>
&lt;h2 id="演習">演習&lt;/h2>
&lt;!-- &lt;details class="spoiler " id="spoiler-4">
&lt;summary>Dockerfileにnavigationを追加してBuildする&lt;/summary>
&lt;p>&lt;/p>
&lt;/details> -->
&lt;details class="spoiler " id="spoiler-5">
&lt;summary>navigationをlaunchして、rviz上で指定した位置までナビゲーションさせてみる&lt;/summary>
&lt;p>&lt;pre>&lt;code>(開発PC)(docker) roslaunch navigation_tutorial navigation.launch
&lt;/code>&lt;/pre>
&lt;/p>
&lt;/details>
&lt;!-- &lt;details class="spoiler " id="spoiler-6">
&lt;summary>navigationをlaunchして、map座標系の位置を指定してナビゲーションさせてみる&lt;/summary>
&lt;p>&lt;/p>
&lt;/details> -->
&lt;details class="spoiler " id="spoiler-7">
&lt;summary>navigationのparamをチューニングする&lt;/summary>
&lt;p>&lt;p>move baseのパラメータは &lt;code>navigation_tutorial/params&lt;/code> の中にyaml形式で保存されています。&lt;/p>
&lt;p>launchファイルではloadコマンドでyamlを読み込んでいます。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://wiki.ros.org/move_base#Parameters">move_base&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://wiki.ros.org/base_local_planner#Parameters">base_local_planner&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://wiki.ros.org/costmap_2d#costmap_2d.2Flayered.Parameters">costmap_2d&lt;/a>&lt;/li>
&lt;/ul>
&lt;/p>
&lt;/details></description></item></channel></rss>